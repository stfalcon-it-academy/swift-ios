/*: 
 ## Optionals (Опциональные типы)
 */
//:
/*:
 **Опциональные типы** используются в тех случаях, когда значение может отсутствовать. Опциональный тип подразумевает:
 
 * значение существует и оно равно `x`
 
 
 или
 
 * значение не существует вовсе.
 */
//:
/*:
 * note: 
 В `C` или `Objective-C` нет понятия опционалов. Ближайшее понятие в `Objective-C` - это возможность вернуть `nil` из метода, который в противном случае вернул бы объект. В этом случае `nil` обозначает **«отсутствие допустимого объекта»**. Тем не менее, это работает только для объектов и не работает для структур, простых типов `C` или значений перечисления. Для этих типов методы `Objective-C`, как правило, возвращают специальное значение (например `NSNotFound`), чтобы указать отсутствие значения. Этот подход предполагает, что разработчик, который вызвал метод знает, что есть это специальное значение и что его нужно учитывать. Опционалы `Swift` позволяют указать отсутствие значения для абсолютно любого типа без необходимости использования специальных констант.
 */
//:
//: Приведем пример, который покажет, как опционалы могут справиться с отсутствием значения. В языке `Swift` тип `String` имеет метод `Int()`, который пытается преобразовать `String` значение в `Int`. Тем не менее, не каждая строка может быть преобразована в целое число. Строка `"123"` может быть преобразована в числовое значение `123`, тогда как строка `"hello, world"` не имеет очевидного числового значения для преобразования.
//:
//: В приведенном ниже примере используется метод `Int()` для попытки преобразовать `String` в `Int`:
//:
import Foundation

let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
//:
//: Поскольку метод `Int()` может иметь недопустимый аргумент вместо `Int` он возвращает опциональный `Int`. Опциональный `Int` записывается как `Int?`. Знак вопроса означает, что соответствующее значение является опциональным, т.е. может или содержать некое `Int` значение или не содержать никакого значения вообще. Также такое значение не может содержать значения других типов, например `Bool` или `String`. Оно  либо `Int` либо `nil`.
//:
/*:
 
 */
//: ### nil (Пустое значение)
//:
//: Мы можем установить опциональную переменную в состояние отсутствия значения путем присвоения ей специального значения `nil`:
//:
var serverResponseCode: Int? = 404
serverResponseCode = nil
//:
/*:
 * note:
 `nil` не может быть использован с не опциональными константами и переменными. Если значение константы или переменной при определенных условиях должно когда-нибудь отсутствовать, всегда объявляйте их с опциональным значением соответствующего типа.
 */
//:
//: Если опциональную переменную объявить без присвоения ей первоначального значения по умолчанию `Swift` автоматически инициирует ее со значением `nil`:
//:
var surveyAnswer: String?
//:
/*:
 * note:
 В языке `Swift` значение `nil` не то же самое, что `nil` в `Objective-C`. В `Objective-C` значение `nil` является указателем на несуществующий объект. В `Swift` значение `nil` не является указателем, а всего лишь обозначает отсутствие значения определенного типа. Устанавливаться в `nil` могут опционалы любого типа, а не только типы объектов.
 */
//: ### If Statements and Forced Unwrapping (Оператор If и Принудительное извлечение)
//:
//: Вы можете использовать оператор `if`, сравнивая опционал с `nil`, чтобы проверить, содержит ли опционал значение. Это сравнение можно сделать с помощью оператора «равенства» (`==`) или оператора «неравенства» (`!=`).
//:
//: Если опционал имеет значение он будет рассматриваться как «неравным» `nil`:
//:
if convertedNumber != nil {
    print("convertedNumber содержит соответствующее числовое значение.")
}
//:
//: Если вы уверены, что опционал содержит значение, то можете получить доступ к его значению, добавив восклицательный знак (`!`) в конце имени опционала. Восклицательный знак фактически говорит: «Я знаю точно, что этот опционал содержит значение, пожалуйста, используй его». Это выражение известно как **Принудительное извлечение значения опционала**:
//:
if convertedNumber != nil {
    print("convertedNumber содержит числовое значение, равное \(convertedNumber!).")
}
//:
/*:
 * note:
 Попытка использовать `!` к несуществующему опциональному значению вызовет `runtime` ошибку. Всегда будьте уверены в том, что опционал содержит `не-nil` значение перед тем, как использовать `!` для принудительного извлечения конкретного значения.
 */
//: ### Optional Binding (Привязка опционалов)
//:
//: Можно использовать **Привязку опционалов**, чтобы выяснить содержит ли опционал значение и в случае положительного ответа сделать это значение доступным в качестве временной константы или переменной. Привязка опционалов может использоваться с операторами `if` и `while` для проверки значения внутри опционала, а также для извлечения этого значения в константу или переменную в рамках одного действия.
//:
/*:
 Схематически привязку опционалов с использованием оператора `if` можно описать следующим образом:

    if let constantName = someOptional {
        statements
    }
 */
//:
//: Мы можем изменить наш пример с константой `possibleNumber`, заменив принудительное извлечение на привязку опционалов:
//:
if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" содержит целое число, равное \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" не может быть преобразовано в целое число")
}
//:
//: Это может быть прочитано как:
//:
//: «Если опциональный `Int`, возвращенный функцией `Int(possibleNumber)` содержит значение присвой его новой константе с именем `actualNumber`».
//:
//: Если преобразование прошло успешно константа `actualNumber` становится доступной для использования внутри первого ветвления оператора `if`. Он уже инициализируется значением, содержащимся внутри опционала и поэтому нет необходимости в использовании `!` для доступа к его значению. В этом примере `actualNumber` используется, чтобы напечатать результат преобразования.
//:
//: Вы можете использовать и константы и переменные для привязки опционалов. Если вы хотите изменять значение `actualNumber` внутри первого ветвления оператора `if` можно написать `if var actualNumber` и значение, содержащееся в опционале будет использоваться как переменная, а не как константа.
//:
//: Вы можете использовать множественные опциональные привязки в единственном операторе `if` с одновременным добавлением условия `where` для логической проверки. Если любое из значений будет равно нулю или условие `where` вернет значение `false` вся конструкция связывания опционалов будет считаться неудачной.
//:
if let firstNumber = Int("4"), secondNumber = Int("42") where firstNumber < secondNumber {
    print("\(firstNumber) < \(secondNumber)")
}
//:
/*:
 * note:
 Константы и переменные, созданные при помощи связывания опционалов с использованием оператора `if` доступны только внутри тела оператора `if`. Для сравнения, константы и переменные, созданные с использованием оператора `guard` доступны в строках кода, следующих за оператором `guard`.

 */
//: ### Implicitly Unwrapped Optionals (Неявно извлеченные опционалы)
//:
//: Как описано выше, опционалы показывают, что константам или переменным разрешено не иметь «никакого значения». Опционалы можно проверить с помощью оператора `if`, чтобы увидеть существует ли значение и при условии, если оно существует можно извлечь его при помощи привязки опционалов для доступа к опциональному значению.
//:
//: Иногда из структуры программы сразу понятно, что опционал всегда будет иметь значение, после того как это значение впервые было установлено. В этих случаях, очень полезно избавиться от проверки и извлечения значения опционала каждый раз при обращении к нему, потому что можно с уверенностью утверждать, что он всегда будет иметь это значение.
//:
//: Эти виды опционалов называются **неявно извлеченные опционалы**. Их можно писать, используя восклицательный знак (`String!`) вместо вопросительного знака (`String?`) после типа, который вы хотите сделать опциональным.
//:
//: Неявно извлеченные опционалы полезны, когда известно, что значение опционала существует непосредственно после первого объявления опционала и точно будет существовать после этого. В языке `Swift` неявно извлечённые опционалы чаще всего используются во время начальной  инициализации классов.
//:
//: Честно говоря, неявно извлеченные опционалы - это нормальные опционалы, но они могут быть использованы как не опциональные значения, без необходимости в извлечении опционального значения каждый раз при доступе. Следующий пример показывает разницу в поведении между опциональной строкой и неявно извлеченной опциональной строкой при доступе к их внутреннему значению как к явной строке:
//:
let possibleString: String? = "An optional string."
let forcedString: String = possibleString!

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString
//:
//: Можно представлять неявно извлеченный опционал как передачу прав опционалу для автоматического извлечения всякий раз, когда он используется. Вместо размещения восклицательного знака после имени опционала каждый раз, когда вы его используете, ставьте восклицательный знак после типа опционала во время его объявления.
/*:
 * note:
 Если вы попытаетесь получить доступ к неявно извлеченному опционалу когда он не содержит значения - вы получите `runtime` ошибку. Результат будет абсолютно тот же, если бы вы разместили восклицательный знак после нормального опционала, который не содержит значения.
 */
//:
//: Вы по прежнему можете обращаться к неявно извлеченному опционалу как к нормальному опционалу, чтобы проверить, содержит ли он значение:
//:
if assumedString != nil {
    print(assumedString)
}
//:
//: Вы также можете использовать неявно извлеченный опционал с привязкой опционалов, чтобы проверить и извлечь его значение в одном выражении:
//:
if let definiteString = assumedString {
    print(definiteString)
}
//:
/*:
 * note:
 Не используйте неявно извлечённый опционал, если существует вероятность, что в будущем переменная может стать `nil`. Всегда используйте нормальный тип опционала, если вам нужно проверять на `nil` значение в течение всего срока службы переменной.
 */
//:
/*:
 
 */
//: [Tuples](@previous) | [Error Handling](@next)
