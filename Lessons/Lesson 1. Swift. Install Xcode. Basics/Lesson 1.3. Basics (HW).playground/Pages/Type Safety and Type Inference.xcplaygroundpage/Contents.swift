/*:
 ## Type Safety and Type Inference (Строгая типизация и вывод типов)
 */
//:
//: `Swift` - язык со **строгой типизацией**. Язык со строгой типизацией призывает вас иметь четкое представление о типах значений, с которыми может работать ваш код. Если часть вашего кода ожидает `String`, вы не сможете передать ему `Int` по ошибке.
//:
//: Поскольку `Swift` имеет строгую типизацию, он выполняет проверку типов при компиляции кода и отмечает любые несоответствующие типы как ошибки. Это позволяет в процессе разработки ловить и как можно раньше исправлять ошибки.
//:
//: Проверка типов поможет вам избежать ошибок при работе с различными типами значений. Тем не менее, это не означает, что при объявлении вы должны указывать тип каждой константы или переменной. Если вы не укажете нужному вам значению тип, то `Swift` будет использовать **вывод типов**, чтобы вычислить соответствующий тип. Вывод типов позволяет компилятору вывести тип конкретного выражения автоматически во время компиляции, просто путем изучения значения, которое вы ему передаете.
//:
//: Благодаря выводу типов `Swift` требует гораздо меньше объявления типов, чем языки, такие как `C` или `Objective-C`. Константам и переменным все же нужно присваивать тип, но большая часть работы по указанию типов будет сделана за вас.
//:
//: Вывод типов особенно полезен, когда вы объявляете константу или переменную с начальным значением. Часто это делается путем присвоения литерального значения (или литерала) константам или переменным в момент объявления​​. **Литеральное значение** - значение, которое появляется непосредственно в исходном коде, например как `42` и `3,14159` в приведенных ниже примерах.
//:
//: Например, если вы присваиваете литеральное значение `42` новой константе, не указав явно какого она типа, `Swift` делает вывод, что вы хотите, чтобы константа была `Int`, потому что вы присвоили ей значение, которое похоже на целое число:
//:
import Foundation

let meaningOfLife = 42
//:
//: Точно так же, если вы не указали тип для литерала с плавающей запятой `Swift` делает вывод, что вы хотите создать `Double`:
//:
let pi = 3.14159
//:
//: `Swift` всегда выбирает `Double` (вместо `Float`), когда выводит тип числа с плавающей запятой.
//:
//: Если объединить целые литералы и литералы с плавающей запятой в одном выражении результирующий тип будет выводится как `Double`:
//:
let anotherPi = 3 + 0.14159
//:
//: Литеральное значение `3` само по себе не имеет явного типа, так что соответствующий тип `Double` выводится из наличия литерала с плавающей запятой как части оператора сложения.
//:
/*:
 
 */
//: [Floating-Point Numbers](@previous) | [Numeric Literals](@next)
