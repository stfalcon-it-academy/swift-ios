/*: ## Dictionaries (Словари) */
//:
//: Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа. Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря. В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка. Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так же как в реальном мире словарь используется для поиска определения конкретного слова.
//:
/*:
 * note:
 В языке `Swift` тип `Dictionary` является мостиком к классу `NSDictionary` из библиотеки `Foundation`.
 */
//:
//: Более подробно о взаимодествии между `Dictionary` и `Foundation and Cocoa` см. в [Using Swift with Cocoa and Objective-C (Swift 2.2)]( https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216 )
//:
/*: */
//: ### Dictionary Type Shorthand Syntax (Сокращенный синтаксис словаря)
//:
//: В `Swift` тип словаря в полной форме пишется как `Dictionary<Key, Value>`, где `Key` - это тип значения, которое используется как ключ словаря, а `Value` - это тип значения, которое словарь может хранить для указаного ключа.
//:
/*:
 * note:
 Тип ключа в словаре должен соответствовать протоколу `Hashable`.
 */
//:
//: Вы можете также написать словарь в сокращенной форме как `[Key: Value]`. Хотя две формы функционально идентичны, краткая форма является предпочтительной и часто используется при обращении к типу словаря.
//:
/*: */
//: ### Creating an Empty Dictionary (Создание пустого словаря)
//:
//: Подобно массивам вы можете создать пустой словарь определенного типа с помощью синтаксиса инициализатора:
//:
import Foundation

var namesOfIntegers = [Int: String]()
//:
//: В этом примере создается пустой словарь с типом `[Int: String]` для хранения удобных для восприятия имен числовых значений. Его ключи имеют тип `Int`, а значения - тип `String`.
//:
//: Если контекст уже предоставляет информацию о типе, вы можете создать пустой словарь с помощью литерала пустого словаря, который пишется как `[:]` (двоеточие внутри пары квадратных скобок):
//:
namesOfIntegers[16] = "sixteen"
namesOfIntegers

namesOfIntegers = [:]
namesOfIntegers.count
//:
/*: */
//: ### Creating a Dictionary with a Dictionary Literal (Создание словаря при помощи литерала)
//:
//: Вы можете инициализировать словарь с помощью литерала словаря, который имеет схожий синтаксис с литералом массива. *Литерал словаря* - это краткий способ написать одну или несколько пар `ключ-значение` в виде коллекций словаря.
//:
//: Пара `ключ-значение` является комбинацией ключа и значения. В литерале словаря, `ключ` и `значение` в каждой паре `ключ-значение` разделено двоеточием. Пары `ключ-значение` написаны как список, разделенный запятыми и окруженный парой квадратных скобок:
//:
//: `[ключ 1: значение 1, ключ 2: значение 2, ключ 3: значение 3]`
//:
//: В следующем примере создается словарь, который хранит имена международных аэропортов. В этом словаре ключи являются трехбуквенным кодом международной ассоциации воздушного транспорта, а значения - названия аэропортов:
//:
var airports1: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
//:
//: Словарь `airports1` объявлен с типом `[​String​: ​String​]`, что означает "словарь ключи которого имеют тип `String` и значения которого также имеют тип `String`".
//:
/*:
 * note:
 Словарь `airports1` объявлен как переменная (при помощи `var`), а не константа (при помощи `let`), поскольку мы будем добавлять в него новые названия других аэропортов.
 */
//:
//: Словарь `airports1` инициализирован с помощью литерала словаря, содержащего две пары `ключ-значение`. Первая пара имеет ключ `"YYZ"` и значение `"Toronto Pearson"`. Вторая пара имеет ключ `"DUB"` и значение `"Dublin"`.
//:
//: Этот словарь содержит две пары `String: String`. Этот тип `ключ-значение` подходит типу, который мы присвоили переменной `airports1` (словарь, содержащий только `String` ключи и только `String` значения) и поэтому присвоение литерала словаря допустимо в качестве способа инициализации словаря `airports` двумя начальным элементами.
//:
//: Подобно массивам, вы можете не писать тип словаря, если инициализируете его с помощью литерала словаря, чьи ключи и значения имеют соответствующие типы. Инициализация `airports2` может быть записана в более краткой форме:
//:
var airports2 = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
//:
//: Поскольку все ключи в литерале имеют одинаковый тип и точно так же все значения имеют одинаковый тип, то `Swift` может вывести, что `[String: String]` является правильным типом для использования в словаре `airports2`.
//:
/*: */
//: ### Accessing and Modifying a Dictionary (Доступ и изменение словаря)
//:
//: Вы можете получить доступ к словарю и изменять его либо через его методы и свойства, либо используя синтаксис индексов.
//:
//: Подобно массивам, вы можете узнать количество элементов в словаре через его read-only свойство `count`:
//:
print("The airports dictionary contains \(airports2.count) items.")
//:
//: Логическое свойство `isEmpty` можно использовать в качестве быстрого способа узнать, является ли свойство `count` равным `0`:
//:
if airports2.isEmpty {
    print("The airports dictionary is empty.")
} else {
    print("The airports dictionary is not empty.")
}
//:
//: Вы можете добавить новый элемент в словарь при помощи синтаксиса индексов. Используйте новый ключ соответствующего типа в качестве индекса, а затем присвойте новое значение соответствующего типа:
//:
airports2["LHR"] = "London"
//:
//: Вы также можете использовать сабскрипт синтаксис для изменения значения, связанного с определенным ключом:
//:
airports2["LHR"] = "London Heathrow"
//:
//: В качестве альтернативы индексам, можно использовать метод словаря `updateValue(_:forKey:)`, чтобы установить или обновить значение для определенного ключа. Подобно примерам с индексами метод `updateValue(_:forKey:)` устанавливает значение для ключа, если оно не существует или обновляет значение, если этот ключ уже существует. Однако, в отличие от индексов, метод `updateValue(_:forKey:)` возвращает старое значение после выполнения обновления. Это позволяет вам проверить состоялось ли обновление или нет.
//:
//: Метод `updateValue(_:forKey:)` возвращает опциональное значение соответствующее типу значения словаря. Например, для словаря, который хранит `String` значения, метод возвратит `String?` тип, или `"опциональный String"`. Это опциональное значение содержит старое значение для этого ключа, если оно существовало до обновления либо `nil`, если значение не существовало.
//:
if let oldValue = airports2.updateValue("Dublin Airport", forKey: "DUB") {
    print("The old value for DUB was \(oldValue).")
}
//:
//: Вы также можете использовать сабскрипт синтаксис, чтобы получить значение из словаря для конкретного ключа. Поскольку есть вероятность запросить ключ для несуществующего значения, индекс словаря возвращает опциональное значение, соответствующее типу значений словаря. Если словарь содержит значение для запрошенного ключа, индекс возвращает опциональное значение, содержащее существующее значение для этого ключа. В противном случае индекс возвращает `nil`:
//:
if let airportName = airports2["DUB"] {
    print("The name of the airport is \(airportName).")
} else {
    print("That airport is not in the airports dictionary.")
}
//:
//: Вы можете использовать сабскрипт синтаксис для удаления пары `ключ-значение` из словаря путем присвоения `nil` значению для этого ключа:
//:
airports2["APL"] = "Apple International"
airports2

airports2["APL"] = nil
airports2
//:
//: Кроме того, можно удалить пару `ключ-значение` из словаря с помощью метода `removeValueForKey(_:)`. Если пара `ключ-значение` существует этот метод удаляет ее и возвращает значение или возвращает `nil`, если такая пара не существует:
//:
if let removedValue = airports2.removeValueForKey("DUB") {
    print("The removed airport's name is \(removedValue).")
} else {
    print("The airports dictionary does not contain a value for DUB.")
}
//:
/*: */
//: ### Iterating Over a Dictionary (Итерация по словарю)
//:
//: Вы можете сделать итерацию в словаре по парам `ключ-значение` при помощи цикла `for-in`. При этом каждое значение возвращается как кортеж (ключ, значение) и вы можете разложить части кортежа по временным константам или переменным в рамках каждой итерации:
//:
for (airportCode, airportName) in airports2 {
    print("\(airportCode): \(airportName)")
}
//:
//: Более подробно цикл `for-in` мы рассмотрим на уроке **Циклы For-In**.
//:
//: Вы также можете получить коллекцию ключей или значений словаря через обращение к его свойствам `keys` и `values`:
//:
for airportCode in airports2.keys {
    print("Airport code: \(airportCode)")
}

for airportName in airports2.values {
    print("Airport name: \(airportName)")
}
//:
//: Если вам нужно использовать ключи или значения словаря вместе с каким-либо API, которое принимает объект `Array`, то можно инициализировать новый массив с помощью свойств `keys` и `values`:
//:
let airportCodes = [String](airports2.keys)
let airportNames = [String](airports2.values)
//:
//: В `Swift` тип `Dictionary` является неупорядоченной коллекцией. Для перебора ключей или значений словаря в определенном порядке используйте метод `sort()` с массивами из свойств `keys` или `values`.
//:
/*: */
//: [Performing Set Operations](@previous) | [Examples. Dictionaries](@next)
