/*: ## Sets (Множества) */
//:
//: **Множество** хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Вы можете использовать множество как альтернативу массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.
//:
/*:
 * note:
 В языке `Swift` тип `Set` связан с классом `NSSet` из библиотеки `Foundation`.
 */
//:
//: О взаимодействии между `Set` и `Foundation and Cocoa` читайте в документации [Using Swift with Cocoa and Objective-C (Swift 2.2)](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216)
//:
/*: */
//: ### Hash Values for Set Types (Хеш значения для типа Set)
//:
//: Тип должен быть хешируемым для того, чтобы храниться в множестве, таким образом тип должен предоставлять возможность для вычисления собственного значения хеша. Тип значения хеша `Int` должен быть для всех объектов одинаковым, чтобы можно было провести сравнение: если `a == b`, то и `a.hashValue == b.hashValue`.
//:
//: Все базовые типы `Swift` (`Int`, `String`, `Double`, `Bool`) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений так же являются хешируемыми по умолчанию.
/*:
 * note:
 Вы можете использовать ваш собственный тип в качестве типа значения множества или типа ключа словаря, подписав его под протокол `Hashable` из стандартной библиотеки `Swift`. Типы, которые подписаны под протокол `Hashable` должны обеспечивать `gettable` свойство `hashValue`. Значение, которое возвращает `hashValue` не обязательно должно иметь одно и то же значение при выполнении одной и той же программы или разных программ. Так как протокол `Hashable` подписан под протокол `Equatable`, то подписанные под него типы так же должны предоставлять реализацию оператора равенства `==`. Протокол `Equatable` требует любую реализацию оператора равенства для реализации возможности сравнения. Таким образом, реализация оператора `==` должна удовлетворять следующим трем условиям, для всех трех значений `a`, `b`, `c`.
 
    `a == a` (Рефлексивность)

    `a == b`, значит `b == a` (Симметрия)

    `a == b` && `b == c`, значит `a == c` (Транзитивность)
 */
//:
/*: */
//: ### Set Type Syntax (Синтаксис типа множества)
//:
//: В языке `Swift` тип `Set` записывается как `Set<Element>`, где `Element` является типом, который храниться в множестве. В отличии от массивов множества не имеют сокращенной формы записи.
/*: */
//:
//: ### Creating and Initializing an Empty Set (Создание и инициалиазация пустого множества)
//:
//: Вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора:
//:
var letters = Set<Character>()
print("letters имеет тип Set<Character> с \(letters.count) элементами.")
//:
/*:
 * note:
 Тип переменной `letters` выведен из типа инициализатора как `Set<Character>`.
 */
//: Альтернативно, если контекст предоставляет информацию о типе, например как аргумент функции или просто явное указание типа переменной или константы, то вы можете создать пустое множество при помощи пустого литерала массива:
//:
letters.insert("a")
letters = []
//:
/*: */
//: ### Creating a Set with an Array Literal (Создание множества при помощи литерала массива)
//:
//: Вы так же можете инициализировать множество при помощи литерала массива, чтобы использовать его в качестве сокращенной записи нескольких элементов в качестве коллекции множества.
//:
//: Следующий пример создает множество `favoriteGenres` для хранения `String`.
//:
var favoriteGenres1: Set<String> = ["Rock", "Classical", "Hip hop"]
//:
//: Переменная `favoriteGenres1` объявлена как множество значений типа `String`, которое записывается как `Set<String>`. Так как это множество имеет определенный тип `String`, то ему позволено хранить только значения типа `String`. Поэтому здесь мы инициализируем `favoriteGenres1` тремя значениями типа `String`, записанными в виде литерала массива.
/*:
 * note:
 Множество `favoriteGenres1` объявлено как переменная (ключевое слово `var`), а не константа (ключевое слово `let`), поскольку в примере мы добавляем и удаляем элементы.
 */
//:
//: Так как тип множества не может быть выведен только из литерала, то его тип должен быть указан явно. Однако из-за вывода типа в `Swift` вы не должны писать тип множества, если вы инициализируете его при помощи литерала массива, который содержит элементы одного типа. Вместо этого инициализация `favoriteGenres1` может быть записана и в более короткой форме:
//:
var favoriteGenres2: Set = ["Rock", "Classical", "Hip hop"]
//: Так как все элементы литерала массива одного типа, то `Swift` может вывести, что `Set<String>` является корректным типом для переменной `favoriteGenres2`.
/*: */
//: ### Accessing and Modifying a Set (Доступ и изменение множества)
//:
//: Получить доступ и модифицировать множества можно через свойства и методы.
//:
//: Для того, чтобы выяснить количество элементов в множестве вам нужно использовать свойство `count`:
//:
print("I have \(favoriteGenres2.count) favorite music genres.")
//:
//: Используйте булево свойство `isEmpty` в качестве сокращенной проверки наличия элементов во множестве или другими словами, равно ли свойство `count` значению `0`:
//:
if favoriteGenres2.isEmpty {
    print("Мне все равно какая музыка играет. Я не придирчив.")
} else {
    print("У меня есть свои музыкальные предпочтения.")
}
//:
//: Вы можете добавить новый элемент во множество, используя метод `insert(_:)`:
//:
favoriteGenres2.insert("Jazz")
//:
//: Вы так же можете удалить элемент из множества, используя метод `remove(_:)`, который удаляет элемент, который является членом множества и возвращает удаленное значение или `nil`, если удаляемого элемента нет. Так же все объекты множества могут быть удалены единовременно при помощи метода `removeAll()`.
//:
if let removedGenre = favoriteGenres2.remove("Rock") {
    print("\(removedGenre)? С меня хватит.")
} else {
    print("Меня это не сильно заботит.")
}
//:
//: Можно проверить наличие определенного элемента во множестве, используя метод `contains(_:)`:
//:
if favoriteGenres2.contains("Funk") {
    print("О! Да я встал с правильной ноги!")
} else {
    print("Слишком много Funk'а тут.")
}
//:
/*: */
//: ### Iterating Over a Set (Итерация по множеству)
//:
//: Вы можете совершать итерации по множеству при помощи цикла `for-in`.
//:
for genre in favoriteGenres2 {
    print("\(genre)")
}
//:
//: В языке `Swift` множества не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке вам нужно использовать функцию `sort()`, которая возвращает коллекцию определенной последовательности.
//:
for genre in favoriteGenres2.sort() {
    print("\(genre)")
}
//:
/*: */
//: [Mutability of Collections](@previous) | [Performing Set Operations](@next)
