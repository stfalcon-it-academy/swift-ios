/*: ## Arrays (Массивы) */
//:
//: Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появится несколько раз в разных позициях.
//:
/*:
 * note:
 В языке `Swift` тип `Array` является мостиком к классу `NSArray` из `Foundation`.
*/
//: Для более подробной информации об использовании `Array` и `Foundation and Cocoa` см. [Using Swift with Cocoa and Objective-C (Swift 2.2)]( https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216 )
//:
/*: */
//: ### Array Type Shorthand Syntax (Сокращённый синтаксис массивов)
//:
//: Полная форма записи массива в `Swift` пишется `Array<Element>`, где `Element` - это тип, который может хранить массив. Вы можете также написать массив в сокращенной форме как `[Element]`. Хотя две формы функционально идентичны, краткая форма является предпочтительной и массово используется при обращении к типу массива.
//:
/*: */
//: ### Creating an Empty Array (Создание пустого массива)
//:
//: Вы можете создать пустой массив определенного типа с помощью синтаксиса *инициализатора*:
//:
import Foundation
import UIKit

var someInts = [Int]()
print("someInts is of type [Int] with \(someInts.count) items.")
//:
//: Обратите внимание, что тип переменной `someInts` выводится как `[Int]` в момент инициализации.
//:
//: Кроме того, если контекст уже содержит информацию о типе, такую как: аргумент функции или уже типизированную переменную или константу, вы можете создать пустой массив при помощи **пустого литерала массива**, который записывается в виде `[]` (пустая пара квадратных скобок):
//:
someInts.append(3)
someInts.count
someInts = []
someInts.count
//:
/*: */
//: ### Creating an Array with a Default Value (Создание массива со значением по умолчанию)
//:
//: В языке `Swift` тип `Array` содержит специальный инициализатор для создания массива определенного размера со значениями, заданными по умолчанию. Вы указываете ему необходимое количество добавляемых элементов (именуемое `count`) и соответствующее значение по умолчанию определенного типа (так называемый `repeatedValue`):
//:
var threeDoubles = [Double](count: 3, repeatedValue: 0.11)
//:
/*: */
//: ### Creating an Array by Adding Two Arrays Together (Создание массива путем сложения двух массивов)
//:
//: Вы можете создать новый массив путем сложения двух существующих массивов с совместимыми типами при помощи **оператора сложения** (`+`). Тип массива определяется исходя из общего типа добавляемых массивов:
//:
var anotherThreeDoubles = [Double](count: 3, repeatedValue: 2.5)
var sixDoubles = threeDoubles + anotherThreeDoubles
//:
/*: */
//: ### Creating an Array with an Array Literal (Литералы массива)
//:
//: Вы можете инициализировать массив с помощью **литерала массива**, который является быстрым способом писать одно или несколько значений как набор значений массива. **Литерал массива** записывается в виде списка значений, разделенных запятыми, в окружении пары квадратных скобок:
//:
//: `[value 1, value 2, value 3]`
//:
//: В приведенном ниже примере создается массив под названием `shoppingList` для хранения значений с типом `String`:
//:
var shoppingList1: [String] = ["Eggs", "Milk"]
//:
//: Переменная `shoppingList` объявлена как "массив из `String` значений", который записывается как `[String]`. Поскольку для этого массива указан тип значения `String`, ему разрешено хранить только `String` значения. Здесь массив `shoppingList` инициализирован двумя `String` значениями (`"Eggs"` и `"Milk"`), написанными внутри литерала массива.
//:
/*:
 * note:
 Массив `shoppingList` объявлен как переменная (с помощью `var`), а не константа (с помощью `let`), поскольку много элементов добавляются в список покупок в примерах ниже.
*/
//: В данном случае литерал массива содержит два `String` значения и больше ничего. Это подходит типу, который мы присвоили при объявлении переменной `shoppingList` (массив который может хранить только `String` значения), и поэтому присвоение литерала массива разрешено как способ инициализации `shoppingList` двумя начальными элементами.
//:
//: Благодаря выводу типов `Swift` вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа. Вместо этого, инициализация `shoppingList` может быть записана в сокращенной форме:
//:
var shoppingList2 = ["Eggs", "Milk"]
//:
//: Поскольку все значения внутри литерала массива одного типа, `Swift` может вывести, что `[String]` является правильным типом для переменной `shoppingList`.
//:
/*: */
//: ### Accessing and Modifying an Array (Доступ и изменение массива)
//:
//: Вы можете получить доступ и вносить изменения в массив либо используя его методы и свойства, либо через синтаксис **сабскриптов**.
//:
//: Чтобы узнать количество элементов в массиве, проверьте его read-only свойство `count`:
//:
print("The shopping list contains \(shoppingList2.count) items.")
//:
//: Логическое свойство `isEmpty` можно использовать в качестве быстрого способа узнать, является ли свойство `count` равным `0`:
//:
if shoppingList2.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list is not empty.")
}
//:
//: Вы можете добавить новый элемент в конец массива через вызов метода `append(_:)`:
//:
shoppingList2.append("Flour")
//:
//: Кроме того, добавить в массив один или несколько совместимых элементов можно при помощи **оператора сложения и присвоения** (`+=`):
//:
shoppingList2 += ["Baking Powder"]
shoppingList2 += ["Chocolate Spread", "Cheese", "Butter"]
//:
//: Извлечь значение из массива можно с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива.
//:
var firstItem = shoppingList2[0]
//:
/*:
 * note:
 Заметьте, что первый элемент в этом массиве имеет индекс `0`, а не `1`. Массивы в `Swift` всегда начинаются с `0`.
*/
//:
//: Вы можете использовать синтаксис сабскриптов для изменения существующего значения данного индекса:
//:
shoppingList2[0] = "Six eggs"
//:
//: Вы также можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяющих значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Следующий пример заменяет `"Chocolate Spread"`, `"Cheese"` и `"Butter"` на `"Bananas"` и `"Apples"`:
//:
shoppingList2
shoppingList2[4...6] = ["Bananas", "Apples"]
shoppingList2
//:
/*:
 * note:
 Вы не можете использовать синтаксис сабскриптов для добавления нового элемента в конец массива.
*/
//:
//: Для вставки элемента по заданному индексу внутрь массива, вызовите его метод `insert(_:atIndex:)`:
//:
shoppingList2.insert("Maple Syrup", atIndex: 0)
//:
//: Вызвав метод `insert(_:atIndex:)` мы вставили новый элемент со значением `Maple Syrup` в самое начало списка покупок, т.е. в элемент с индексом `0`.
//:
//: Аналогичным образом можно удалить элемент из массива с помощью метода `removeAtIndex(_:)`. Этот метод удаляет элемент с указанным индексом и возвращает удалённый элемент (хотя вы можете игнорировать возвращаемое значение, если оно вам не нужно):
//:
let mapleSyrup = shoppingList2.removeAtIndex(0)
//:
/*:
 * note:
 Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующей границы массива, это вызовет ошибку времени выполнения. Вы можете увидеть, что индекс действителен до его использования по отношению к свойству `count` массива. За исключением случаев, когда количество равно `0` (т.е. массив пуст), наибольший допустимый индекс в массиве всегда будет `count - 1`, потому что массивы индексируются с нуля.
 */
//:
//: Любые пробелы внутри массива закрываются когда удаляется элемент и поэтому значение с индексом `0` опять равно `"Six eggs"`:
//:
firstItem = shoppingList2[0]
//:
//: Если вы хотите удалить последний элемент из массива, то можно использовать метод `removeLast()` вместо `removeAtIndex(_:)`, чтобы избежать необходимости запроса свойства `count` для массива. Также как и `removeAtIndex(_:)` метод `removeLast()` возвращает удаленный элемент:
//:
let apples = shoppingList2.removeLast()
//:
/*: */
//: ### Iterating Over an Array (Итерация по массиву)
//:
//: Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла `for-in`:
//:
for item in shoppingList2 {
    print(item)
}
//:
//: Если вам нужен целочисленный индекс каждого значения так же, как и самое значение, используйте вместо этого глобальную функцию `enumerate` для итерации по массиву. Функция `enumerate` возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента. Вы можете разложить кортеж во временные константы или переменные в рамках итерации:
//:
for (index, value) in shoppingList2.enumerate() {
    print("Item \(index + 1): \(value)")
}
//:
//: Более детально цикл `for-in` мы рассмотрим на уроке **For-In циклы**.
//:
/*: */
//: [Mutability of Collections](@previous) | [Examples. Arrays](@next)
